function PTPsubjectSessionInfo(remote)
%
% This script analyzes certain aspects of data from PTP participants and
% stores these data on the scc.
%
% Requires the following software:
%   FL voice
%   conn
%   Statistical Toolbox
%
% INPUTS    remote                  0/1
%                                       0: run on the scc
%                                       1: run locally via conn
% 
% Outputs saved on the scc via conn.
% .../AudDev/derivatives/acoustic/subID/[subID]_task-aud-reflexive_desc-sessioninfo
%
% [subID]_desc-sessioninfo.mat is a file that contains the following variables
%           gender                  string array indicating gender
%           sessTimes               4x6 vector with session dates/times extracted
%                                       from expParams.sessTimes
%           baselinef0              1x4 vector of each session's
%                                   baselinef0 value. 
%                                   Generated by flvoice_firstlevel
%           baselineF1              1x4 vector of each session's 
%                                   baselineF1 value.
%                                   Generated by flvoice_firstlevel
%           baselinef0_CI           1x4 vector representing the confidence 
%                                   interval of each session's baselinef0 value. 
%           baselineF1_CI           1x4 vector representing the confidence 
%                                   interval of each session's baselineF1 value. 
%           LOWf0                   1x4 logical that provides the index of the
%                                   session with the lowest baseline f0
%           HIGHf0                  1x4 logical that provides the index of the
%                                   session with the highest baseline f0
%           LOWF1                   1x4 logical that provides the index of the
%                                   session with the lowest baseline F1
%           HIGHF1                  1x4 logical that provides the index of the
%                                   session with the highest baseline F1
%           MORNING                 1x4 logical that provides the index of
%                                   the sessions conducted in the morning
%           pert                    1x4 cell array that specifies the
%                                   shift type of each adaptive session
%           percentBad              1x4 vector of percent trials removed through
%                                   QC in each session 
%           percentBadConds         1x4 struct with six fields, one per condition,
%                                   of percent trials remaining in each
%                                   condition after QC
%           
%
% Written by Elaine Kearney, Mar 2022 (elaine-kearney.com)
% Adapted by Alexander Acosta, August 2022

%% setup

subIDs = PTPsubjectIDs('aud-reflexive')';

% set dirs
rootDir = PTPsetup(remote);

% Init across-subject cell arrays
numSub = numel(subIDs);
LOWf0Subs = cell(numSub,1);
HIGHf0Subs = cell(numSub,1);
LOWF1Subs = cell(numSub,1);
HIGHF1Subs = cell(numSub,1);
LOWF2Subs = cell(numSub,1);
HIGHF2Subs = cell(numSub,1);
LOWFRatioSubs = cell(numSub,1);
HIGHFRatioSubs = cell(numSub,1);
percentBadReflexiveSubs = cell(numSub,1);
percentBadAdaptiveSubs = cell(numSub,1);
MORNINGSubs = cell(numSub,1);
pertSubs = cell(numSub,1);

%% Extract data within subjects

for s = (1:numel(subIDs))

    % Init dirs

    sub = subIDs{s};

    subDir = fullfile(rootDir, sub);
    derivDir = fullfile(rootDir, 'derivatives', 'acoustic', sub);
    
    % Init matrices

    numSess = 4;
    sessTimes = zeros(numSess,6);
    baselinef0 = zeros(1,numSess); f0std = baselinef0;
    baselineF1 = zeros(1,numSess); F1std = baselineF1;
    baselineF2 = zeros(1, numSess); F2std = baselineF2;
    baselineFRatio = zeros(1,numSess); FRatiostd = baselineFRatio;
    baselinef0_CI = zeros(1,numSess);
    baselineF1_CI = zeros(1,numSess);
    baselineF2_CI = zeros(1,numSess);
    baselineFRatio_CI = zeros(1,numSess);
    pert = strings;
    percentBadReflexive = zeros(1,4);
    percentBadAdaptive = zeros(1,4);
    conditions = {'U0', 'D0', 'N0', 'U1', 'D1', 'N1'};

    % Analyze by session

    for ses = 1:numSess

        sesDir = fullfile(subDir, sprintf('ses-%d', ses), 'beh'); task = 'aud-reflexive';
        FN = fullfile(sesDir, sprintf('%s_ses-%d_run-1_task-%s.mat', sub, ses, task));
        fprintf('loading file %s from the SCC\n', FN)
        if remote, FN = conn_cache('pull',  FN); end
        load(FN, 'expParams')

        % extract session times
        sessTimes(ses,:) = expParams.sessionTime;
        
        %% Reflexive Runs Analysis

        % load QC data
        QC = flvoice_import(sub, [ses ses ses ses ses ses ses], [1 2 3 4 5 6], 'aud-reflexive', 'get_qc');

        % Load trial data
        trialData = flvoice_import(sub, [ses ses ses ses ses ses ses], [1 2 3 4 5 6], 'aud-reflexive', 'output');

        % Create sesData struct by applying QC to trial data and extracting
        % conditions
        sesData = {};
        for r = 1:6
            trialDataQC = trialData{1,r}(QC{1,r}.keepData); % Apply QC
            condsKept = {trialDataQC(:).condLabel}; % Struct of containing all kept trials' conditions
            sesData = [sesData condsKept]; % Collect trial data across runs into greater sesData cell array
        end

        % Calculate % of trials removed via QC
        numTrials = numel(sesData);
        percentBadReflexive(1,ses) = ((180-numTrials)/180)*100;
        % sub-PTP ses 2 has weird trial #, accounting for
        if strcmp(sub,'sub-PTP001') && ses == 2, percentBadReflexive(1,ses) = ((167-numTrials)/167)*100; end

        % Calculate % of each condition still present
        for c = 1:6
            idxCond = strfind(sesData, conditions{c}); % Collect trial indices of a given condition
            numCond = numel(idxCond(~cellfun('isempty',idxCond))); % Collect number of trials of a given condition
            % percentBadConds0(i ,ses) = ((30-numCond)/30)*100; % Load number of trials into percentBadConds matrix
            
            percentBadConds(ses).(conditions{c}) = ((30-numCond)/30)*100;
            if strcmp(sub,'sub-PTP001') && ses == 2, percentBadConds(ses).(conditions{c}) = NaN; end
        end

        % Establish baselinef0 and baselineF1 for each session

        % baselinef0 
        % calculated from N0 trial data
        % time range is from 450 ms before pert onset (t = 0)
        task = 'aud-reflexive';

        contrastName = sprintf('ses-%d-%s-baselinef0', ses, task);
        design = {'N0'};
        contrastVec = 1; 
        timeFunc = @(t) (t<0 & t>-.450);

        baselinef0Struct = flvoice_firstlevel(sub, ses, 'all', task, contrastName, 'F0-mic', design, contrastVec, timeFunc, 'REFERENCE', false, 'PRINT', false);
        baselinef0(1, ses) = baselinef0Struct.effect;
        baselinef0_CI(1:2,ses) = baselinef0Struct.effect_CI(:,1); close

        % derive std
        f0std = std(baselinef0Struct.stats.Y);

        % baselineF1
        % calculated from N1 trials
        % time range is from 0 ms to 450 ms after pert onset (t = 0)
        design = {'N1'};
        contrastVec = 1;
        timeFunc = @(t) (t>0&t<.450);

        contrastNameF1 = sprintf('ses-%d-%s-baselineF1', ses,task);
        baselineF1Struct = flvoice_firstlevel(sub, ses, 'all', task, contrastNameF1, 'F1-mic', design, contrastVec, timeFunc, 'REFERENCE',false, 'PRINT', false);
        baselineF1(1, ses) = baselineF1Struct.effect;
        baselineF1_CI(1:2,ses) = baselineF1Struct.effect_CI(:,1); close

        F1std(ses) = std(baselineF1Struct.stats.Y);

        % baseline f2
        % calculated from N1 trials
        % time range is from 
        design = {'N1'};
        contrastVec = 1;
        timeFunc = @(t) (t>0&t<.450);

        contrastNameF2 = sprintf('ses-%d-%s-baselineF2', ses,task);
        baselineF2Struct = flvoice_firstlevel(sub, ses, 'all', task, contrastNameF2, 'F2-mic', design, contrastVec, timeFunc, 'REFERENCE',false, 'PRINT', false);
        baselineF2(1, ses) = baselineF2Struct.effect;
        baselineF2_CI(1:2,ses) = baselineF2Struct.effect_CI(:,1); close

        F2std(ses) = std(baselineF2Struct.stats.Y);

        % Calculate F2/F1 ratio baseline
        baselineFRatioTrials = zeros(numel(baselineF2Struct.stats.Y),1);
        for t = 1:numel(baselineF2Struct.stats.Y)
            baselineFRatioTrials(t) = baselineF2Struct.stats.Y(t) / baselineF1Struct.stats.Y(t);
        end

        baselineFRatio(1,ses) = mean(baselineFRatioTrials,'all');

        FRatiostd(ses) = std(baselineFRatioTrials);

        % CI
        SEM = std(baselineFRatioTrials);             % Standard Error
        ts = tinv([0.025  0.975],length(baselineFRatioTrials)-1);      % T-Score
        baselineFRatio_CI([1 2],ses) = mean(baselineFRatioTrials) + ts*SEM;  

        %% Adaptive Runs Analysis
        task = 'aud-adaptive';
        if strcmp(sub, 'sub-PTP001')
            if ses == 1
                adaptRun = remoteLoad(remote, fullfile(sesDir, sprintf('%s_ses-%d_run-8_task-%s.mat', sub, ses, task)));
                QC = flvoice_import(sub, ses, 8, 'aud-adaptive', 'get_qc');
            elseif ses == 4
                adaptRun = remoteLoad(remote, fullfile(sesDir, sprintf('%s_ses-%d_run-9_task-%s.mat', sub, ses, task)));
                QC = flvoice_import(sub, ses, 9, 'aud-adaptive', 'get_qc');
            else
                adaptRun = remoteLoad(remote, fullfile(sesDir, sprintf('%s_ses-%d_run-7_task-%s.mat', sub, ses, task)));
                QC = flvoice_import(sub, ses, 7, 'aud-adaptive', 'get_qc');
            end
        else
            adaptRun = remoteLoad(remote, fullfile(sesDir, sprintf('%s_ses-%d_run-7_task-%s.mat', sub, ses, task)));
            QC = flvoice_import(sub, ses, 7, 'aud-adaptive', 'get_qc');
        end

        % Pull adaptive pert direction
        pert(ses) = convertCharsToStrings(adaptRun.expParams.pertDirect);
    
        % Determine % bad trials
        badData = find(~QC.keepData); 
        percentBadAdaptive(1,ses) = (numel(badData)/270) * 100;

    end

    close
    
    gender = expParams.gender;

    %% Analyze session data

    % Determine low/high session indices for f0 and F1
    % Sort sesions by baseline f0 
    [~,I] =sort(baselinef0);
    lowIdx = I(1);
    low = zeros(1,4);
    low(1,lowIdx) = 1;
    LOWf0 = logical(low);
    
    highIdx = I(4);
    high = zeros(1,4);
    high(1,highIdx) = 1;
    HIGHf0 = logical(high);

    [~,I] =sort(baselineF1);
    lowIdx = I(1);
    low = zeros(1,4);
    low(1,lowIdx) = 1;
    LOWF1 = logical(low);
    
    highIdx = I(4);
    high = zeros(1,4);
    high(1,highIdx) = 1;
    HIGHF1 = logical(high);

    [~,I] =sort(baselineF2);
    lowIdx = I(1);
    low = zeros(1,4);
    low(1,lowIdx) = 1;
    LOWF2 = logical(low);
    
    highIdx = I(4);
    high = zeros(1,4);
    high(1,highIdx) = 1;
    HIGHF2 = logical(high);

    [~,I] =sort(baselineFRatio);
    lowIdx = I(1);
    low = zeros(1,4);
    low(1,lowIdx) = 1;
    LOWFRatio = logical(low);
    
    highIdx = I(4);
    high = zeros(1,4);
    high(1,highIdx) = 1;
    HIGHFRatio = logical(high);

    % Find earliest sessions
    [~,I] =sort(sessTimes(:,4));
    morningIdx = I(1:2);
    morning= zeros(1,4);
    morning(1,morningIdx) = 1;
    MORNING = logical(morning);

    % Save analytical variables above into across-subjects variables
    LOWf0Subs{s,1} = find(LOWf0); HIGHf0Subs{s,1} = find(HIGHf0);
    LOWF1Subs{s,1} = find(LOWF1); HIGHF1Subs{s,1} = find(HIGHF1); MORNINGSubs{s,1} = find(MORNING);
    LOWF2Subs{s,1} = find(LOWF2); HIGHF2Subs{s,1} = find(HIGHF2); MORNINGSubs{s,1} = find(MORNING);
    LOWFRatioSubs{s,1} = find(LOWFRatio); HIGHFRatioSubs{s,1} = find(HIGHFRatio); MORNINGSubs{s,1} = find(MORNING);
    pertSubs{s,1} = pert; percentBadReflexiveSubs{s,1} = percentBadReflexive;
    percentBadAdaptiveSubs{s,1} = percentBadAdaptive;

    %% Save subject info on the scc
    
    if remote
        conn_savematfile(fullfile(rootDir, 'derivatives', 'acoustic', sprintf('%s', sub), ...
            sprintf('%s_desc-sessioninfo.mat', sub)), ...
            'gender', 'sessTimes', 'baselinef0', 'baselineF1', 'baselinef0_CI', 'baselineF1_CI', ...
            'baselineF2', 'baselineF2_CI', 'baselineFRatio', 'baselineFRatio_CI', ...
            'f0std', 'F1std', 'F2std', 'FRatiostd', 'LOWf0', 'HIGHf0', 'LOWF1', 'HIGHF1', 'LOWF2', ...
            'HIGHF2', 'LOWFRatio', 'HIGHFRatio', 'MORNING', 'pert', 'percentBadReflexive', 'percentBadConds', 'percentBadAdaptive');
        conn_cache clearall
    else
        save(fullfile(rootDir, 'derivatives', 'acoustic', sprintf('%s', sub), ...
            sprintf('%s_desc-sessioninfo.mat', sub)), ...
            'gender', 'sessTimes', 'baselinef0', 'baselineF1', 'baselinef0_CI', 'baselineF1_CI', ...
            'baselineF2', 'baselineF2_CI','baselineFRatio', 'baselineFRatio_CI', ...
            'f0std', 'F1std', 'F2std', 'FRatiostd', 'LOWf0', 'HIGHf0', 'LOWF1', 'HIGHF1', 'LOWF2', ...
            'HIGHF2', 'LOWFRatio', 'HIGHFRatio', 'MORNING', 'pert', 'percentBadReflexive', 'percentBadConds', 'percentBadAdaptive');
    end
end

% Write across-subject variables to a single structure
subjects = [subIDs LOWf0Subs HIGHf0Subs LOWF1Subs HIGHF1Subs LOWF2Subs HIGHF2Subs ...
    LOWFRatioSubs HIGHFRatioSubs pertSubs percentBadReflexiveSubs percentBadAdaptiveSubs];
T = cell2table(subjects, 'VariableNames', ...
    {'Subject IDs', 'Low f0 Session', 'High f0 Session', 'Low F1 Session', 'High F1 Session', ...
    'Low F2 Session', 'High F2 Session', 'Low FRatio Session', 'High FRatio Session', ...
    'Adaptive Pert Direction', '% Bad Reflexive Trials Per Session', '% Bad Adaptive Trials Per Session'});

% Export structure to a .csv file
fileName = 'results_desc-sessioninfo.csv';
if remote
    saveDir = uigetdir(cd, 'Please select a directory to save the .csv file containing subject data.');
    writetable(T, fullfile(saveDir, fileName));
else
    writetable(T, fullfile(rootDir, 'derivatives', 'acoustic', 'results', fileName));
end
end